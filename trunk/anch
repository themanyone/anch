#!/bin/bash
#set -x
# search function echos position in array or nothing
pos() {
    c=0
    local hay needle=$1
    shift
    for hay; do
        if [[ $hay == $needle ]]; then echo $c; return 0;fi
    ((c++))
    done; return 1
}
if [[ !$1 || $(pos "-h" $@) ]]; then
cat <<EOF
Usage: `basename $0` [CC] [cflags] [libs] [-run] source.anch [program args]

Examples, -run
$ `basename $0` -lm -std=c99 -run test.anch arg1 arg2

Static builds
$ `basename $0` gcc -c mylib1.anch -o mylib1.o
$ `basename $0` gcc -c myprog.anch -o myprog.o
$ gcc mylib1.o myprog.o -o myprog

As a "shebang" line
#!/usr/local/bin/anch [cflags] [ldflags] -run [args]

Makefiles: See README
EOF
exit 0
fi 
ax=($@)
# assume first file that exists is input source code
for x in "${ax[@]}"; do
    if [[ -f "$x" ]]; then in="$x"; fi
done
run=$(pos "-run" $@)
end=$(pos $in $@)
#integration with tcc -run [args]
if [[ "$run" && "$end" ]]; then
    cflags=${ax[@]:0:$run}
    args=${ax[@]:$run+1:$end-$run-1}
    args+=" "${ax[@]:$end+1}
    gcc='tcc '
    run='-run '
# if not tcc, assume $1 is compiler to use
elif [[ "$in" ]]; then
    opt=$(pos "-o" $@)
    gcc=$1
    args+=${ax[@]:$opt}
    cflags=${ax[@]:1:$(pos $in $@)-1}
else
# who knows? maybe it came from a pipe
    if [[ -z $(pos "-" $@) ]]; then
        echo No input files.
        exit 1
    elif [[ -z $(pos "tcc" $@) ]]; then
        gcc='tcc '
    fi
        anchor -qp | $gcc "$@"
    exit 0
fi
src="${in##./}"
tmp=".${src%.*}.c"

# make a hidden .temp.c file
# get rid of shebang if not tcc compiler
s=($(<$in)[0])
if [[ $gcc != "tcc " && ${s:0:2} == "#!" ]]; then
    anchor -qp "$in" | tail -n +2 > "$tmp"
else
    anchor -qp "$in" > "$tmp"
fi

if [[ "${cflags:0:2}" == '$(' ]]; then
    cflags=$(${cflags:2:-1})
fi
# compile the temp file with options. remove if successful
$gcc ${cflags} $run "$tmp" ${args[@]}&&rm "$tmp"
# if build fails, tmp file remains for debugging
